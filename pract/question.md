# PE2 Practice: Infinite Hotpot

You got copyrighted for your amazing work with the Demon Slayer simulation, so you decided to quit that and open a hotpot 
restraunt instead. This time, you got inspired by HaiDiLao and how infinite and vast the ocean feels, you decided to make it
an Infinite Hotpot themed restraunt, naming it **Hotpot**.

In this exercise, you will practice **functional-style programming** using `Stream`, and higher-order operations such as `map`, `filter`, `flatMap`, and `reduce` etc.

Do not decompile the test classes, you can directly run them. Decompiling may cause issues with testing. You should not require creating a new list or any data structure in this practice other than using `toList()` or `stream()`.


You are given the following class:

```java
public class Hotpot {
    private List<Ingredient> ingredients;

    public Hotpot(List<Ingredient> ingredients) {
        this.ingredients = ingredients;
    }

    // various methods to be implemented or completed
}
```
There is also an `Ingredient` class that should not be modified.
The examples use Ingredient objects such as:

```java
new Ingredient("Cabbage", true)
new Ingredient("Mushroom", true)
new Ingredient("Carrot", true)
```

Each task below describes a functionality that you should implement.

Task 1 – `String chop(long n)`

Of course, you need to be able to chop the ingredients. Your implementation should repeat each ingredient `n` times, 
simulating chopping each ingredient into `n` pieces. We assume input `n` will always be more than 1 as we don't want any
headache.

Return all pieces as a `String` with line breaks.

Sample output: 
```java
   jshell> // Suppose we have an Hotpot containing:
      ...> //  new ("Cabbage", true)
      ...> //  new ("Mushroom", true)
      ...> //  new ("Carrot", true)
   jshell> Hotpot.chop(2)
   $.. ==> 
   Uncooked Cabbage
   Uncooked Cabbage
   Uncooked Mushroom
   Uncooked Mushroom
   Uncooked Carrot
   Uncooked Carrot
   jshell> // Suppose we have an Hotpot containing:
      ...> //  new ("Cabbage", true)
      ...> //  new ("Cabbage", true)
   jshell> Hotpot.chop(1)
   $.. ==> 
   Uncooked Cabbage
   Uncooked Cabbage
```
You can test your implementation by running:
```shell
java Test1
```

Task 2 – `List<Ingredient> cook()`

Next, you want to cook the ingredients to avoid food poisoning. Ensure that you only cook the fresh ones.

Rreturn a new List<Ingredient> of cooked ingredients.

Sample output:
```java
jshell> // Suppose the pot contains:
   ...> //  new ("Cabbage", true)
   ...> //  new ("Carrot", false)
   ...> //  Tnew ("Tofu", true)
jshell> pot.cook().get(0)
$.. ==> Cooked Cabbage
jshell> pot.cook().get(1)
$.. ==> Cooked Tofu
```
You can test your implementation by running:
```shell
java Test2
```

Task 3 – `long mostOrderedAmount()`

Sometimes you like a specific ingredient so much you take multiple of it. Implement a method to find the number of times
the most ordered ingredient appears. Hint: you can use `Math.max()` for this.

Return the highest number of repeated orders of any ingredient in the list.

Sample output:
```java
jshell> // Suppose the pot contains:
   ...> //  new ("Cabbage", true),
        // new ("Cabbage", true),
        // new ("Carrot", true),
        // new ("Carrot", true),
        // new ("Carrot", true),
jshell> pot.mostOrderedAmount()
$.. ==> 3
jshell> // Suppose the pot contains:
   ...> // new ("Cabbage", true),
        // new ("Cabbage", true),
        // new ("Carrot", true),
        // new ("Carrot", true),
        // new ("Meat", true),
jshell> pot.mostOrderedAmount()
$.. ==> 2
```
You can test your implementation by running:
```shell
java Test3
```

Task 4 – `List<Ingredient> takeUnique()`

To maximize trying as many ingredients as possible, you want to ensure you only take 1 of each ingredient and avoid
any repeats. Implement a method that removes any duplicates. You should not be using `distinct()`.

Return an `List` containing only the first occurrence of each ingredient (i.e., remove duplicates while preserving order).

p.s. this question was partially generated by chatgpt which then required some manual fixing. It's ok if you don't know how
to implement this, but a tip is to think of the equality between ingredients. The solution I found only required 4 List
methods.

Sample output:
```java
jshell> // Suppose the pot contains:
   ...> // new ("Cabbage", true),
        // new ("Cabbage", true),
        // new ("Mushroom", true),
        // new ("Mushroom", true),
        // new ("Carrot", true),
jshell> pot.takeUnique().get(0)
$.. ==> Uncooked Cabbage
jshell> pot.takeUnique().get(1)
$.. ==> Uncooked Mushroom

jshell> // Suppose the pot contains:
   ...> // new ("Meat", true),
        // new ("Cabbage", true),
        // new ("Mushroom", true),
        // new ("Mushroom", true),
        // new ("Meat", true),
jshell> pot.takeUnique().get(0)
$.. ==> Uncooked Meat
jshell> pot.takeUnique().get(2)
$.. ==> Uncooked Mushroom
```
You can test your implementation by running:
```shell
java Test4
```

Task 5 – `String combine(Hotpot other)`

Now, you want to be able to add another infinite pot into your infinite pot. Of course, your stomach is not infintie,
so you only want to add 1 of each ingredient that **is not already in the current pot**. Implement a method that
combines two infinite pots together, keeping:

- All ingredients from the current pot, and
- Only unique new ingredients from the other pot (no duplicates).

Return a `String` to show the ingredients of your combined pot.

Hint: you can use a previous method to help with this.

Sample output:
```java
jshell> // Suppose the first pot contains:
   ...> // new ("Cabbage", true),
        // new ("Cabbage", true),
        // new ("Mushroom", true),
        // new ("Mushroom", true),
        // new ("Carrot", true),
jshell> // Suppose the second pot contains:
   ...> // new ("Cabbage", true),
        // new ("Meat", true),
        // new ("Potato", true),
        // new ("Mushroom", true),
        // new ("Carrot", true),
jshell> pot1.combine(pot2)
$.. ==> Uncooked Cabbage
        Uncooked Cabbage
        Uncooked Mushroom
        Uncooked Mushroom
        Uncooked Carrot
        Uncooked Meat
        Uncooked Potato
        
jshell> // Suppose the first pot contains:
   ...> // new ("Cabbage", true),
        // new ("Cabbage", true),
        // new ("Mushroom", true),
        // new ("Mushroom", true),
        // new ("Carrot", true),
jshell> // Suppose the second pot contains:
   ...> // new ("Cabbage", true),
        // new ("Meat", true),
        // new ("Potato", true),
        // new ("Mushroom", true),
        // new ("Carrot", true),
jshell> new Hotpot(pot1.cook()).combine(pot2)
$.. ==> Cooked Cabbage
        Cooked Cabbage
        Cooked Mushroom
        Cooked Mushroom
        Cooked Carrot
        Uncooked Meat
        Uncooked Potato
```
You can test your implementation by running:
```shell
java Test5
```

Task 6 - `String mostOrdered()`

Finally, you want to find out which ingredient is most ordered. Implement a method to get the popular ingredients.

Return a String showing the ingredients that appearede the most.

Sample output:

```java
jshell> // Suppose the pot contains:
   ...> // new ("Cabbage", true),
        // new ("Cabbage", true),
        // new ("Mushroom", true),
        // new ("Mushroom", true),
        // new ("Carrot", true),
jshell> pot.mostOrdered()
$.. ==> Uncooked Cabbage
        Uncooked Mushroom

jshell> // Suppose the pot contains:
   ...> // new ("Meat", true),
        // new ("Meat", true),
        // new ("Meat", true),
jshell> pot.mostOrdered()
$.. ==> Uncooked Meat

jshell> // Suppose the pot contains:
   ...> // new ("Cabbage", true),
        // new ("Mushroom", true),
        // new ("Carrot", true),
jshell> pot.mostOrdered()
$.. ==> Uncooked Cabbage
        Uncooked Mushroom
        Uncooked Carrot

```

You can test your implementation by running:
```shell
java Test6
```
After doing all that, you are exhausted and decided the cs life is better. So you went home and did some logic questions 
instead. In the file `Logic.java`, there are 2 tasks you can try to transform into functional style.

You can use both streams and InfiniteList to solve, either works. There are no testcase for that but you can use the 
code provided to see expected output by running

```shell
javac Logic.java
java Logic
```
